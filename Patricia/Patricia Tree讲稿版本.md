#PPT演示版本

###page 1

本次实验我们所抽到的题目是 Patricia Tree.

###page 2

我们将分为如下几个部分来进行我们Presentation.

###page 3

在计算机科学中，Trie 结构是一种常用于检索的数据结构，中文翻译为字典树或者是前缀树，和大多数树形结构不一样的是，它使用边来表示信息，结点表示这个状态（字符串）存在与否以及包含的其余的信息。

基于这种存储结构，很显然一个节点的所有子孙都有相同的前缀。

对于一个如下的键值对情形，我们可以生成这样的Trie树。

> 指一下 PPT 上的那个图。

这是一种查找效率非常高的数据结构，对于字符串的查找其最坏情况为 $O(w)$，其中 $w$ 是待查字符串的长度。

通常在实现 Trie 树的时候，我们通过保存字符集大小的`child`数组指针来逐个字符的实现 Trie 树的结点存储，但是这么做的会造成很大程度的空间消耗（这是一种以空间换时间的策略），因此智慧的后人便提出了许多的改进方式。

### page 4

D. MORRSON 教授在 1968 年对 Trie 结构进行了改进，发明了 Trie 结构的一个变体  PATRICIA-TRIES (Practical Algorithm to Retrieve Information Coded in Alphanumeric)

Trie 树有许多只包含一个孩子的结点，为了提高空间的利用效率，Patricia 这种结构将一连串的『独生子女』压缩成一个结点，PATRICIA 树兄弟结点的关键字一定有相同的前缀。

> 指一下 PPT 上的图表。

可以看到的是其中对于相同的前缀进行了压缩处理，只是从粗略的角度看，这种方式相当于把可能出现的单链表压缩到了一个结点，在实现与 Trie 树相同的时间效率下，达到更优的空间存储效率。

自此，弥补了 Trie 这一类结构因为空间效率而不能够被广泛使用的缺憾。

### page 5

结构上的改进所带来的自然是编程复杂度的提升，但是我们的工作便是致力于为大家剖析清楚这种数据结构，并附上了详尽的文档和实现代码可供大家参考。

通俗的讲，Patricia Tree 的逻辑特点如下。

> 指一下 PPT 上的图表。

这里有如上几个特点，在这里我重点说明一下第三点。
如果一个结点只有一个子结点，那么它将会和这个子结点一起压缩成为一个结点，且这个过程逐级向下递推。(这就是我刚才说的对于独生子女的压缩)
第四点也是显而易见的兄弟结点之间一定有相同的关键前缀。

### page 6

基于以上的特点，该数据结构能够高效的支持如下的操作，且时间效率均表现良好。
对于时间的分析将在接下来详细讲述。

### page 7

接下来我们需要考虑的是？具体怎么实现 Patricia 呢？

在此次项目中，我们亲手实现了一个和网上相关代码都不太一样的 PAT Tree 并且测试的效果要高于 Github 上部分用户实现的源代码。

相关部分的定义如图

> 指一下PPT

在存储结构（即结点）定义上，我们定义了采取了传统的数据库查询方式，定义了键值对`(Key,Value)`。其中`key`用作结构信息的存储，`value`在终结结点被记录，可以通过查询键的方式获得值，`terminal` 作为终结结点的标志。

值得注意的是，也是本次我们实现的一个创新点，我们使用`map`存储出现过的孩子结点的首字母与相应指针的映射关系，通过这种方式，我们可以避免对 alphabet 中的每一个字符都提前预置数组指针的空间。

这部分具体的优势我们在链接给出的讲义里进行了分析。

### page 8

接下来我们需要关心的是，如何来实现 PAT 结构的相关操作？

在我们插入的时候，其从策略上遵从，寻找到第一个和当前已有结点有分支的结点，然后对当前结点进行分裂，但是在实现的过程中我们需要考虑以下的几种情况。

>- 若树为空，直接创建一个叶子节点存储待插入字符串。
>- 若插入的字符串首字符未出现在当前结点，创建一个新叶子节点存储这个字符串。

第一点是显然的。
第二点如下图，我们将`water`插入当前的PAT，因为 w 这个字符并未出现在根节点的孩子当中，因此它不可能是任何已有字符的前缀，我们直接创建一个新节点存储这个字符。

### page 9

接下来

若插入的字符串 B 和当前已有字符串 A 可以前缀匹配，我们又需要细分几种情况进行讨论。

B 是 A 的前缀，对于如下情形，test 是 tester 的前缀，我们需要在插入 test 的过程中对 tester 进行分裂，并且在 test 这个标签结束的位置设置一个终结标记。

### page 10

A 是 B 的前缀，如下情形，我们插入 slower 这个字符串，此时这个 PAT 中已经存在着 slow 这个串，我们沿着 slow 遍历到终结的地方，给 slow 做一个终结标记，记录下 slow 对应的 value 值，接下来再向外延伸出 er 结点作为分支，并标记上结束标记以及对应的 value 值。

### page 11

A 和 B 有部分公共的前缀，如下情形，我们试着插入 team ，A 串 test 和 B 串 team 有部分前缀重合 te，因此我们需要比对前缀重合的部分，将原结点 key 值修改为 te 然后切分出子串 am 和 st ，生成子结点 am 和 st，成为原结点的儿子，且将原结点的终结标记修改为 false。

### page 12

伪代码部分如下，上面算法中函数 LCP 为寻找两个字符串的最长公共前缀，例如字符串 bool (布尔)和 boy（男孩）的最长公共前缀为 bo。

### page 13

我认为根据伪代码写出算法是理解算法最好的方式，因为只有这样我们才会跟深刻体会算法中一些小的细节对于最终结果的影响。

### page 14

查找的过程通过不断的匹配子串来完成，我们不断的对当前结点递归的进行子串匹配的操作，每次都尝试进行尽可能多的子串匹配，中间过程如果出现不匹配则返回false，否则这个过程就一直执行下去直到匹配到串的终点且终点结点的 terminal 标记为 true。

对于 toasting 的查找，我们首先根据当前结点去匹配上 t，接下来往下一个结点走，尝试匹配 oast成功之后再匹配ing，在ing这个节点检查 terminal 标记，注意这个过程中如果有一个地方不匹配，递归应该终止并返回 false。

### page 15

查询操作伪代码如下

### page 16

对于删除首先需要我们去定位待删除的结点，进行一次与 insert 相同的子串的匹配，但是实际操作的情形比 insert 时简单许多，因为如果子串不能和当前结点完全匹配，我们只需要输出 false 即可

当子串和当前结点长度相同且完全匹配时，我们删除这个结点，并根据其子结点的关系合并子结点到父节点上。

当子串比当前结点的长度更长时，截取出长的那一部分，然后我们递归的使用长出的这一部分进行新一次的删除操作。

这部分的操作和插入有些类似，伪代码就不放了，留作思考。

### page 17

前缀查询也是 PAT 所支持的一种特性操作，其在实际生活中有十分广泛的应用。

### page 18

现在我们来分析如何实现这个操作，首先我们函数设计的接口应该是如下情形。

返回值应该是一个string数组。

### page 19

首先我们的目标是根据prefix找到一个包含这个prefix的结点，

首先我们要沿着prefix，逐个从根节点向下进行匹配，如果prefix已经匹配的长度大于当前结点Key值的长度，那么我们继续向下拓展.


### page 20

直到拓展到第一个key的长度大于当前还未匹配的prefix长度的结点，**注意这里**，我们需要将已经走过的结点的前缀记录下来，存放到一个`ans_prefix`变量里面，然后对这个结点进行一次dfs。

在 dfs 的过程中记录 ans 串，当遇到终结标志时，不要停止 dfs 而是应该将这个 ans 串加入 ret 数组里面，因为对于树的 dfs 是无环的，所以我们可以在不用任何特判的 return 语句的情况下完成这次的 dfs。

注意，在dfs的过程中，我们记录的 ans 实际上是没有考虑 `ans_prefix`的，之后需要做一个处理，将记录下来的串都加上`ans_prefix`。

对于这个例子，我们如果需要搜索前缀带有 to 的所有串，我们需要先对 t 进行匹配，ans_prefix 此时加上 t，接下来下一个结点的 key 是 oast，我们尝试对 o 与 oast 进行匹配，此时我们拓展到了第一个 key 的长度大于当前还未匹配的 prefix长度的结点，因此我们的匹配过程终止，我们将 oast 加入 ans_prefix，对这个节点进行一次搜索，我们还可以得出的结论是，这棵树所有带有 to 前缀的串一定都以 toast 为前缀。

### page 21

有的同学可能会问了，你说了那么多，我怎么知道 PAT 一定比 Trie 好呢？

本次实验中，我们针对插入，删除，查找三个基本操作，进行了时间效率的测试，最后还统计出了两种数据结构的空间消耗作为对比测试。

测试文本为 The snow of kilimanjaro by Hemingway.

全文大约有1.7W个单词。

首先是插入的对比测试，可以从图中看出的是，Patricia由于存在着比Trie更多的分裂结点的操作， 因此在插入时并不占优，此外由于我们实现的Patricia采取的动态分配内存的方式，而Trie采取的是默认静态空间存储，因此在动态分配内存的过程中也会相对更耗时一点，但也只是常数时间的细微差距。

### page 22

接下来进行的是查找和删除的测试，在查找过程中，由于相同数据状态下 Patricia 的结构较 Trie 树结点数目少很多，因此查找时对于递归调用，明显 Patricia 要更占优势。

在删除的时候，我们首先执行的是上一步的查找操作，因为 Patricia 在查找待删除串的过程会比 Trie 快出不少，而同时又因为 Trie 的结点数目更多，我们删除的过程中调用delete时的次数比 Patricia 要多出许多，因此 Patricia 在删除的过程中也更占优势。

### page 23

最后一个图进行的是空间消耗的比较，Trie 结构使用了接近250M的内存，而 Patricia 结构只使用了50M多一些，节省了四倍多的空间。

### page 24
接下来，我们还需要考虑的是，Patricia有哪些更具体一些的应用呢？

我们从各个渠道找到了相关的应用，以及我们自己设想或实现的应用会在之后由武德浩为大家呈现。

最容易想到的自然是，信息检索。

不过因为分词的关系，这部分的应用更多的是用在电子词典，存储单词与详细信息的键值对，我们通过查找单词，获取这个单词的中文解释，详细含义，例句等等信息。



### page 25

还有就是前缀查询，它广泛的应用于词典软件，搜索引擎当中，这部分的应用与我们的日常生活息息相关，当然还有许多老旧的图书馆，政府机关等等系统不支持这个功能，因此以后我们工作后如果遇到这样的情况，上司需要让我们改进这个功能的时候，大家就可以回过头来看这篇 Patricia 的文档，然后实现上司的需求，加薪升职，迎娶白富美了。

### page 26

Merkle Tree可以看做Hash List的泛化

在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root。

很显然这个 Merkle Tree 虽然名字这么高端，但是其仍然是一个前缀树应用到Hash的例子，通过兄弟结点运算出的hash值，生成父结点，因此父节点必然与孩子节点之间具有前缀性。

梅克尔树广泛的用于数据校验作用。

在p2p网络下载网络之前，先从可信的源获得文件的Merkle Root。一旦获得了树根，就可以从不可信的源获取Merkle tree。通过可信的树根来检查接受到的Merkle Tree。如果Merkle Tree是损坏的或者虚假的，就从其他源获得另一个Merkle Tree，直到获得一个与可信树根匹配的Merkle Tree。

值得一提的是，以太坊提出的比特币验证方案正是用了五颗 Merkle Tree 来分别管理交易，状态，账单等等信息。

更多的信息我们在文档中给出了，可以参考文档进行了解。

### page 27

接下来是和下学期我们会学到的计算机网络相关的问题。

在网络方面有一个十分棘手的问题叫做IP Routing Lookup Algorithms，就是路由器需要对接收到的包，快速的对其IP地址在路由表中查询最长匹配的前缀，以确定一个准确的终点地址。

当同时考虑到并发性和效率的时候，以前采用过的许多方法都显得不那么高效，因为路由可能会在一秒钟之内接到上千个包，而一般路由表中存放的元素大约有30000多项。

这实际上就是一个不那么纯粹的前缀匹配的问题，只是最终结点的匹配是模糊的，我们可以在 $O(w)$ 的时间内同时匹配出多个可能的结果，通过计算失配的字符数目我们可以得到一个最小失配串，作为我们 BMP 查询的结果。

### page 28

对于一个给定的输入串，比如为 192.168.0.0，我们可以通过使用 PAT 树去查询所有 IP 所属192.168.....下的子网IP，这是基于之前前缀查询的应用。

### page 29

值得一提的是，在网络上我们找到了一道百度公司出的相关面试题。

题目大意是维护100亿个url地址，我们需要实现一个系统来完成上述的功能。

这道题目也是一个关于 Patricia tree 在分布式环境下的一个应用。

我们直接跳过分布式存储这方面的困难，直接考虑将 url 直接放在本地，那么我们应该怎么去组织这些 url呢，一种思路是使用数据库的方式，但是我们现在可以将 url 组织成树状结构，显然为了满足快速选出一个站点下所有 url 这个性质，我们就必须得用 Trie 结构了，但是考虑到数据规模是 100 亿，因此我们不得不选择 PAT 结构，相比如传统 Trie 可以节约大量空间。

### page 30

然后呢，还有其他的一些改进吗？答案是，当然有，人类的智慧是无穷无尽的，我们始终有神一样的前辈们和潮水一般的后继者。

- HAT-Trie 一种利用缓存来提升存取速度的数据结构，固定有序的管理结点所在的位置（通过一开始分配指针数组），来提高 CPU 的 cache 命中率，非常黑科技。
- Adaptive radix tree 是一种动态管理儿子结点的Trie结构，它可以动态的根据子结点的个数分配内存，每个结点存儿子结点的指针都是动态的，这样做可以更好的节省空间，这种结构既可以用在 Trie 上也可以用在 Patricia 上，在本次的 Patricia tree 中我们实现的就是一个 Adaptive radix tree 结构，我们使用了`std::map<char,patricia_tree<K,V> *>`来管理儿子节点，并且提供 $O(\log_{n})$ 的索引速度。 

### page 31

有请武德浩，浩哥登场为我们展示我们结合 Qt 做出的应用。

### page 32

最后是一些瞎话啦。

本着异步与并行的思想嘛

我们一开始制定了一个比较科学的分工。
本次实验我（李博）在前期主要负责 Patricia Tree 和传统 Trie Tree 类的结构设计与代码实现。前期给武德浩留出了准备 Qt 和设计应用的时间。
当我完成了数据结构相关的代码，并将设计接口交接给武德浩之后，我就直接开始了准备文档，报告，PPT 的工作，此时我和武德浩并行的处理着我们的项目，他一边攻克着 Qt 当中所遇到的无数难题（比如画树，图表展示，文本判重设计等），我一边浏览着无数相关 Patricia Tree 的各路博客与Paper，准备我们最后的文档部分，也就是这篇万字（xia che）长文。

### page 33

但是！胜在浩哥给力，负责，敢于面对困难，迎难而上，敢于承担起责任。
因此我们中间过程中并未出现进程死锁，单方面资源闲置的情况。
本着对课程负责，对听我们讲的同学们负责的态度，以及内心的一些执念。
我们一边又一遍的修改着 GUI，修改着代码里出现的隐患，修改着PPT，讲稿……
累并快乐着~
这是我大学以来最愉快的一次合作。

**最后还要感谢一直帮助我们的助教林可学长和一年来一直在关心激励我们的张岩老师，以及一直耐心的听着我们讲解，强忍住想扔瓶子冲动的大家。**










